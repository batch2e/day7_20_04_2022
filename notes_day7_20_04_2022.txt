 
  public class Customer {



  }


  public class Address {


  }

 public class Main {
   public static void main(String args[]) {
    Address address=new Address();
    Customer customer=new Customer();
    address.setHno();
    address.setCity():
    customer.setId();
    customer.setFirstName();
    customer.setAddress(address);
    System.out.println("The details");
    int id=customer.getId();
    String firstName=customer.getFirstName();
    address=customer.getAddress();
    int hno=address.getHno();
    System.out.println(hno);
    String city=address.getCity();
    System.out.println(city);
   }
}



https://www.geeksforgeeks.org/unified-modeling-language-uml-class-diagrams/

* Inheritance is for reusability of code.
* extends keyword is used for inheritance.
* private members of the Parent class are not inherited.
* default/protected/public members are inherited.
* With the object of child class we can access the public, protected and default member of the parent class.

  public class Parent1{
 
   public void displayParent(){
   System.out.println("I am a method in the Parent class");
   }
 }

 public class Child1 extends Parent1{
   public void displayChild(){
    System.out.println("I am a method in the Child class");
   }
}

  public class InheritDemo1{
    public static void main(String args[]){
      Parent1 parent=new Parent1();
      parent.displayParent();
      //parent.displayChild();
      Child1 child=new Child1();
      child.displayParent();
      child.displayChild();
     }
  }
 
 // Parent class object cannot access child class member whereas child class object can access the parent class members( condition 
is the members should not be private).

------------------------------------------------------------------------------------------------------------------------------------
Constructor call in inheritance.
* We have two types of constructors
  ** default or parameterless
  ** parameterized constructor

// parameterless constructor call
  public class Parent2 {
    private int num1;
   
    public int getNum1(){
     return num1;
    }
 }

  public class Child2 extends Parent2 {
    private int num2;
    
    public int getNum2(){
     return num2;      
    }
  }

   public class ParentChildMain2{
    public static void main(String args[]){
       Child2 child=new Child2();
       child.getNum1();   // 0
       child.getNum2();   //0
     }
   }

 // In the above example we have not defined any setter methods for num1 and num2 and we have also not mentioned any 
 // constructor . So the default constructor is provided during the compilation and that initialised num1 and num2 with 0.

--------------------------------------------------------------------------------------------------------------------------------


 public class Parent3 {
    private int num1;
   
     public Parent3(){
       num1=20;
       System.out.println("I am the parameterless constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child3 extends Parent3 {
    private int num2;

    public Child3() {
      // super();  // this is called implicitly and meant for invoking the parent class parameterless constructor
       num2=200;
       System.out.println("I am the parameterless constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain3{
    public static void main(String args[]){
       Child3 child=new Child3();
       System.out.println(child.getNum1());   // 20
       System.out.println(child.getNum2());   // 200
     }
   }

/* 
I am the parameterless constructor of parent
I am the parameterless constructor of the Child class
20
200
*/

By now, you have learnt that the derived classes inherit from the base class. You will now see how the child class object is created. As you all know, constructors are invoked while creating objects. When a child class object is created, the child class constructor invokes the parent class constructor before executing any statement present in the child constructor.
------------------------------------------------------------------------------------------------------------------
Parameterized constructor
// super is used represent the immediate parent class. So in our example
// Parent4 is the immediate parent class of Child4

 public class Parent4 {
    private int num1;
   
     public Parent4(int num1){
       this.num1=num1;
       System.out.println("I am the parameterized constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child4 extends Parent4 {
    private int num2;

    public Child4(int num1,int num2) {
       super(num1); // we have to explicitly invoke the parent class parameterized constructor  
       this.num2=num2;
       System.out.println("I am the parameterized constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain4{
    public static void main(String args[]){
       Child4 child=new Child4(100,200);
       System.out.println(child.getNum1());   // 100
       System.out.println(child.getNum2());   // 200
     }
   }

---------------------------------------
From the parameterized constructor of the child class if we dont make a call to the
parent class parameterized constructor, what will happen?



public class Parent5{
    private int num1;
   
     public Parent5(int num1){
       this.num1=num1;
       System.out.println("I am the parameterized constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child5 extends Parent5 {
    private int num2;

    public Child5(int num1,int num2) {
      // super(num1); // we have to explicitly invoke the parent class parameterized constructor  
      // If we are not writing super(num1) explicitly , super() is carried out implicitly
       this.num2=num2;
       System.out.println("I am the parameterized constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain5{
    public static void main(String args[]){
       Child5 child=new Child5(100,200);
       System.out.println(child.getNum1());   // 100
       System.out.println(child.getNum2());   // 200
     }
   }

// The above code will show compilation error as the parameterized constructor is
// trying to invoke the default constructor but we have not defined any default or
// parameterless constructor in the parent class.

Q So is the default constructor is not provided implicitly during compilation?
A Yes if non of the constructor is defined in the class but in the above example
we have one parameterized constructor in the parent class. That is the reason
compiler wont provide any parameterless constructor . We have to explicitly write
the parameterless constructor.



public class Parent6{
    private int num1;
    
     public Parent6(){
      num1=2000;
      System.out.println("I am the parameterless constructor of the Parent class");
     }

     public Parent6(int num1){
       this.num1=num1;
       System.out.println("I am the parameterized constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child6 extends Parent6 {
    private int num2;

    public Child6(int num1,int num2) {
      // super(num1); // we have to explicitly invoke the parent class parameterized constructor  
      // If we are not writing super(num1) explicitly , super() is carried out implicitly
       this.num2=num2;
       System.out.println("I am the parameterized constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain6{
    public static void main(String args[]){
       Child6 child=new Child6(100,200);
       System.out.println(child.getNum1());   // 2000
       System.out.println(child.getNum2());   // 200
     }
   }

// So calling or invoking the Parent class constructor should be the first line
// in the child class constructor otherwise it is a compilation error


   public Child(int num1, int num2){
   this.num2=num2;
   super(num1);
   }
  // So the above snippet shows that we cannot invoke base class constructor at any
other point of time. It has to be called in the first line of the Child class constructor.
The above code is with error.

---------------------------------
public class Employee{}
public class Educator{}

What we cannot write....

 public class Manager extends Employee,Educator{}
// We dont have the concept of a java class extending multiple classes or inheriting 
multiple classes.

--------------------------------------------------------------------------------------------------------------------------------------
Polymorphism:====> poly means many morphic====> body structure 
* Method overloading====> Static or compile time polymorphism
* Method overriding =====> dynamic or runtime polymorphism
------------------------------------------------------------------------------------------------------------------------------------

public class Number1 {
    private int num1;
    private int num2;
    private int num3;
    private float f1;
    private float f2;

    public int add(int num1, int num2, int num3){
       this.num1=num1;
       this.num2=num2;
       this.num3=num3;
       return this.num1+this.num2+this.num3;
     }

    public int add(int num1,int num2){
     this.num1=num1;
     this.num2=num2;
     num3=100;
     return this.num1+this.num2+num3;
    }
    
   /* public void add(int num1, int num2){
     this.num1=num1;
     this.num2=num2;
     System.out.println(this.num1+this.num2);
    } */
   /* We will have comilation error for the above two methods as their parameter numbers and types are same but
    we have changed the return type. But we dont decide method overloading just with the return type of the methods */
    public float add(float f1, float f2){
    
      this.f1=f1;
      this.f2=f2;
      return this.f1+this.f2;
    }

   public float add(int num1, int num2, int num3,float f1, float f2){
       this.num1=num1;
       this.num2=num2;
       this.num3=num3;
       this.f1=f1;
       this.f2=f2;
       return this.num1+this.num2+this.num3+this.f1+this.f2;
     }
  }
    
 public class NumberMain1 {
    public static void main(String args[]) {
      Number1 number=new Number1();
      System.out.println(number.add(1,2));
      System.out.println(number.add(2,3,4));
      System.out.println(number.add(1.2f,2.3f));
      System.out.println(number.add(1,2,3,2.3f,4.5f));
     // System.out.println(number.add(1));  Compilation error because we dont have any add method with a single parameter       

   }
 }

// As the method call is checked during the compilation time, method overloading is called as compile time polymorphism.
--------------------------------------------------------------------------------------------------------------------------------------
Method overriding

       public class Parent7 {
  
         public void dispParent(){
             System.out.println("I am the parent class disp Parent method");
         }

       public void display(){     // overridden
               System.out.println("I am the display method of the Parent class");
       }
   }

   public class Child7 extends Parent7 {
       public void dispChild(){
            System.out.println("I am the Child class disp Child method");
       }
       public void display(){      // overriding
             System.out.println("I am the display method of the Child class");
       }
    }
// In the below class display method is present but the Child7b is not having any parent child relationship with the classes
// mentioned in the example. So we cannot decide that display in the below class is a overridden or overriding method.
// But in Parent7 we have a display method which is the method overridden and the Child7 is having the display method
// If we have two methods with 
   * method name same
   * return type same
   * number of parameters same
   * data type of parameters same
   * The classes are having parent child relationship
Then we say that the method in the derived class is overriding the method in the base/parent class. So the derived class method
is overriding and base class method is overridden.

// which is overriding method

   public class Child7b {
     public void display(){
             System.out.println("I am the display method of the Child7b class");
       }

   }

   public class ParentChildMain7{
          public static void main(String args[]){
              Child7 child=new Child7();
              child.dispParent();
              child.dispChild();
              child.display();
              Parent7 parent=new Parent7();
              parent.dispParent();
              parent.display();
         }
    }
Observations:-
   * displayParent() is specific to the Parent class and displayChild() is specific to Child class.
   * display() method is present both in Parent class and the Child class.

              
Output:
I am the parent class disp Parent method
I am the Child class disp Child method
I am the display method of the Child class  // This is because of method overriding.
I am the parent class disp Parent method
I am the display method of the Parent class


For method overriding :-
* We should have two classes related with Parent Child relationship.
-----------------------------------------------------------------------------------------
 private=====>default====>protected=====>public
// Private is the most restrictive access and public is the least restrictive access
// In the Parent class the access specifier is with less restriction whereas in Child class it is with the most restrictive one.

// Cannot reduce the visibility of the inherited method from Parent8

       public class Parent8 {
  
      

       public void display(){     // overridden
               System.out.println("I am the display method of the Parent class");
       }
   }

   public class Child8 extends Parent8 {
      
       private void display(){      // overriding
             System.out.println("I am the display method of the Child class");
       }
    }

 public class ParentChildMain8{
          public static void main(String args[]){
              Child8 child=new Child8();
           
         }
    }
-------------------------------------------------------------------------


   public class Parent9 {
  
      

      void display(){     // overridden
               System.out.println("I am the display method of the Parent class");
       }
   }

   public class Child9 extends Parent9 {
      
       public void display(){      // overriding
             System.out.println("I am the display method of the Child class");
       }
    }

 public class ParentChildMain9{
          public static void main(String args[]){
              Child9 child=new Child9();
           
         }
    }