 
  public class Customer {



  }


  public class Address {


  }

 public class Main {
   public static void main(String args[]) {
    Address address=new Address();
    Customer customer=new Customer();
    address.setHno();
    address.setCity():
    customer.setId();
    customer.setFirstName();
    customer.setAddress(address);
    System.out.println("The details");
    int id=customer.getId();
    String firstName=customer.getFirstName();
    address=customer.getAddress();
    int hno=address.getHno();
    System.out.println(hno);
    String city=address.getCity();
    System.out.println(city);
   }
}



https://www.geeksforgeeks.org/unified-modeling-language-uml-class-diagrams/

* Inheritance is for reusability of code.
* extends keyword is used for inheritance.
* private members of the Parent class are not inherited.
* default/protected/public members are inherited.
* With the object of child class we can access the public, protected and default member of the parent class.

  public class Parent1{
 
   public void displayParent(){
   System.out.println("I am a method in the Parent class");
   }
 }

 public class Child1 extends Parent1{
   public void displayChild(){
    System.out.println("I am a method in the Child class");
   }
}

  public class InheritDemo1{
    public static void main(String args[]){
      Parent1 parent=new Parent1();
      parent.displayParent();
      //parent.displayChild();
      Child1 child=new Child1();
      child.displayParent();
      child.displayChild();
     }
  }
 
 // Parent class object cannot access child class member whereas child class object can access the parent class members( condition 
is the members should not be private).

------------------------------------------------------------------------------------------------------------------------------------
Constructor call in inheritance.
* We have two types of constructors
  ** default or parameterless
  ** parameterized constructor

// parameterless constructor call
  public class Parent2 {
    private int num1;
   
    public int getNum1(){
     return num1;
    }
 }

  public class Child2 extends Parent2 {
    private int num2;
    
    public int getNum2(){
     return num2;      
    }
  }

   public class ParentChildMain2{
    public static void main(String args[]){
       Child2 child=new Child2();
       child.getNum1();   // 0
       child.getNum2();   //0
     }
   }

 // In the above example we have not defined any setter methods for num1 and num2 and we have also not mentioned any 
 // constructor . So the default constructor is provided during the compilation and that initialised num1 and num2 with 0.

--------------------------------------------------------------------------------------------------------------------------------


 public class Parent3 {
    private int num1;
   
     public Parent3(){
       num1=20;
       System.out.println("I am the parameterless constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child3 extends Parent3 {
    private int num2;

    public Child3() {
      // super();  // this is called implicitly and meant for invoking the parent class parameterless constructor
       num2=200;
       System.out.println("I am the parameterless constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain3{
    public static void main(String args[]){
       Child3 child=new Child3();
       System.out.println(child.getNum1());   // 20
       System.out.println(child.getNum2());   // 200
     }
   }

/* 
I am the parameterless constructor of parent
I am the parameterless constructor of the Child class
20
200
*/

By now, you have learnt that the derived classes inherit from the base class. You will now see how the child class object is created. As you all know, constructors are invoked while creating objects. When a child class object is created, the child class constructor invokes the parent class constructor before executing any statement present in the child constructor.
------------------------------------------------------------------------------------------------------------------
Parameterized constructor
// super is used represent the immediate parent class. So in our example
// Parent4 is the immediate parent class of Child4

 public class Parent4 {
    private int num1;
   
     public Parent4(int num1){
       this.num1=num1;
       System.out.println("I am the parameterized constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child4 extends Parent4 {
    private int num2;

    public Child4(int num1,int num2) {
       super(num1); // we have to explicitly invoke the parent class parameterized constructor  
       this.num2=num2;
       System.out.println("I am the parameterized constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain4{
    public static void main(String args[]){
       Child4 child=new Child4(100,200);
       System.out.println(child.getNum1());   // 100
       System.out.println(child.getNum2());   // 200
     }
   }

---------------------------------------
From the parameterized constructor of the child class if we dont make a call to the
parent class parameterized constructor, what will happen?



public class Parent5{
    private int num1;
   
     public Parent5(int num1){
       this.num1=num1;
       System.out.println("I am the parameterized constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child5 extends Parent5 {
    private int num2;

    public Child5(int num1,int num2) {
      // super(num1); // we have to explicitly invoke the parent class parameterized constructor  
      // If we are not writing super(num1) explicitly , super() is carried out implicitly
       this.num2=num2;
       System.out.println("I am the parameterized constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain5{
    public static void main(String args[]){
       Child5 child=new Child5(100,200);
       System.out.println(child.getNum1());   // 100
       System.out.println(child.getNum2());   // 200
     }
   }

// The above code will show compilation error as the parameterized constructor is
// trying to invoke the default constructor but we have not defined any default or
// parameterless constructor in the parent class.

Q So is the default constructor is not provided implicitly during compilation?
A Yes if non of the constructor is defined in the class but in the above example
we have one parameterized constructor in the parent class. That is the reason
compiler wont provide any parameterless constructor . We have to explicitly write
the parameterless constructor.



public class Parent6{
    private int num1;
    
     public Parent6(){
      num1=2000;
      System.out.println("I am the parameterless constructor of the Parent class");
     }

     public Parent6(int num1){
       this.num1=num1;
       System.out.println("I am the parameterized constructor of parent");
   }
    public int getNum1(){
     return num1;
    }
 }

  public class Child6 extends Parent6 {
    private int num2;

    public Child6(int num1,int num2) {
      // super(num1); // we have to explicitly invoke the parent class parameterized constructor  
      // If we are not writing super(num1) explicitly , super() is carried out implicitly
       this.num2=num2;
       System.out.println("I am the parameterized constructor of the Child class");
      }

    public int getNum2(){
     return num2;      
    }
  }

 public class ParentChildMain6{
    public static void main(String args[]){
       Child6 child=new Child6(100,200);
       System.out.println(child.getNum1());   // 2000
       System.out.println(child.getNum2());   // 200
     }
   }

// So calling or invoking the Parent class constructor should be the first line
// in the child class constructor otherwise it is a compilation error


   public Child(int num1, int num2){
   this.num2=num2;
   super(num1);
   }
  // So the above snippet shows that we cannot invoke base class constructor at any
other point of time. It has to be called in the first line of the Child class constructor.
The above code is with error.

---------------------------------
public class Employee{}
public class Educator{}

What we cannot write....

 public class Manager extends Employee,Educator{}
// We dont have the concept of a java class extending multiple classes or inheriting 
multiple classes.

--------------------------------------------------------------------------------------------------------------------------------------
Polymorphism:====> poly means many morphic====> body structure 
* Method overloading====> Static or compile time polymorphism
* Method overriding =====> dynamic or runtime polymorphism
------------------------------------------------------------------------------------------------------------------------------------

public class Number1 {
    private int num1;
    private int num2;
    private int num3;
    private float f1;
    private float f2;

    public int add(int num1, int num2, int num3){
       this.num1=num1;
       this.num2=num2;
       this.num3=num3;
       return this.num1+this.num2+this.num3;
     }

    public int add(int num1,int num2){
     this.num1=num1;
     this.num2=num2;
     num3=100;
     return this.num1+this.num2+num3;
    }
    
   /* public void add(int num1, int num2){
     this.num1=num1;
     this.num2=num2;
     System.out.println(this.num1+this.num2);
    } */
   /* We will have comilation error for the above two methods as their parameter numbers and types are same but
    we have changed the return type. But we dont decide method overloading just with the return type of the methods */
    public float add(float f1, float f2){
    
      this.f1=f1;
      this.f2=f2;
      return this.f1+this.f2;
    }

   public float add(int num1, int num2, int num3,float f1, float f2){
       this.num1=num1;
       this.num2=num2;
       this.num3=num3;
       this.f1=f1;
       this.f2=f2;
       return this.num1+this.num2+this.num3+this.f1+this.f2;
     }
  }
    
 public class NumberMain1 {
    public static void main(String args[]) {
      Number1 number=new Number1();
      System.out.println(number.add(1,2));
      System.out.println(number.add(2,3,4));
      System.out.println(number.add(1.2f,2.3f));
      System.out.println(number.add(1,2,3,2.3f,4.5f));
     // System.out.println(number.add(1));  Compilation error because we dont have any add method with a single parameter       

   }
 }

// As the method call is checked during the compilation time, method overloading is called as compile time polymorphism.
--------------------------------------------------------------------------------------------------------------------------------------
Method overriding

       public class Parent7 {
  
         public void dispParent(){
             System.out.println("I am the parent class disp Parent method");
         }

       public void display(){     // overridden
               System.out.println("I am the display method of the Parent class");
       }
   }

   public class Child7 extends Parent7 {
       public void dispChild(){
            System.out.println("I am the Child class disp Child method");
       }
       public void display(){      // overriding
             System.out.println("I am the display method of the Child class");
       }
    }
// In the below class display method is present but the Child7b is not having any parent child relationship with the classes
// mentioned in the example. So we cannot decide that display in the below class is a overridden or overriding method.
// But in Parent7 we have a display method which is the method overridden and the Child7 is having the display method
// If we have two methods with 
   * method name same
   * return type same
   * number of parameters same
   * data type of parameters same
   * The classes are having parent child relationship
Then we say that the method in the derived class is overriding the method in the base/parent class. So the derived class method
is overriding and base class method is overridden.

// which is overriding method

   public class Child7b {
     public void display(){
             System.out.println("I am the display method of the Child7b class");
       }

   }

   public class ParentChildMain7{
          public static void main(String args[]){
              Child7 child=new Child7();
              child.dispParent();
              child.dispChild();
              child.display();
              Parent7 parent=new Parent7();
              parent.dispParent();
              parent.display();
         }
    }
Observations:-
   * displayParent() is specific to the Parent class and displayChild() is specific to Child class.
   * display() method is present both in Parent class and the Child class.

              
Output:
I am the parent class disp Parent method
I am the Child class disp Child method
I am the display method of the Child class  // This is because of method overriding.
I am the parent class disp Parent method
I am the display method of the Parent class


For method overriding :-
* We should have two classes related with Parent Child relationship.
-----------------------------------------------------------------------------------------
 private=====>default====>protected=====>public
// Private is the most restrictive access and public is the least restrictive access
// In the Parent class the access specifier is with less restriction whereas in Child class it is with the most restrictive one.

// Cannot reduce the visibility of the inherited method from Parent8

       public class Parent8 {
  
      

       public void display(){     // overridden
               System.out.println("I am the display method of the Parent class");
       }
   }

   public class Child8 extends Parent8 {
      
       private void display(){      // overriding
             System.out.println("I am the display method of the Child class");
       }
    }

 public class ParentChildMain8{
          public static void main(String args[]){
              Child8 child=new Child8();
           
         }
    }
-------------------------------------------------------------------------


   public class Parent9 {
  
      

      void display(){     // overridden
               System.out.println("I am the display method of the Parent class");
       }
   }

   public class Child9 extends Parent9 {
      
       public void display(){      // overriding
             System.out.println("I am the display method of the Child class");
       }
    }

 public class ParentChildMain9{
          public static void main(String args[]){
              Child9 child=new Child9();
           
         }
    }

-------------------------------------------------------------------------

public class Address {
private String hno;
private String city;
private String locality;
private int code;


// Right click on the editor====> Source======> generate constructor with fields

public Address(String hno, String city, String locality, int code) {
	super();
	this.hno = hno;
	this.city = city;
	this.locality = locality;
	this.code = code;
}



public String getHno() {
	return hno;
}
public void setHno(String hno) {
	this.hno = hno;
}
public String getCity() {
	return city;
}
public void setCity(String city) {
	this.city = city;
}
public String getLocality() {
	return locality;
}
public void setLocality(String locality) {
	this.locality = locality;
}
public int getCode() {
	return code;
}
public void setCode(int code) {
	this.code = code;
}


}





public class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private Address address;
	public Customer(String customerId, String customerName, long contactNumber,
			Address address) {
		this.customerId = customerId;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	public double payBill(double totalPrice) {
		System.out.println("Final bill for the customer is calculated here");
		return totalPrice;
	}
	// displayCustomerDetails()
	// updateDetails() overloaded methods
	// getter and setter methods
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public long getContactNumber() {
		return contactNumber;
	}
	public void setContactNumber(long contactNumber) {
		this.contactNumber = contactNumber;
	}
	public Address getAddress() {
		return address;
	}
	public void setAddress(Address address) {
		this.address = address;
	}
	
}



public class RegularCustomer extends Customer {
	private float discountPercentage;
	public RegularCustomer(String custId, String custName, long mobileNo,
			Address address) {
		super(custId, custName, mobileNo, address);
		this.discountPercentage = 5.0f;
	}
	@Override
	public double payBill(double totalPrice) {
		double priceAfterDiscount = totalPrice
				* (1 - (discountPercentage / 100));
		return priceAfterDiscount;
	}
	// getter and setter methods
}


public class Tester {
	public static void main(String[] args) {
	/*	// Customer object created
              /*  Address address=new Address("D089", "St. Louis Street", "Springfield", 62729);
		Customer customer = new Customer("C101", "Stephen Abram", 7856341287L,address); */
              Customer customer = new Customer("C101", "Stephen Abram", 7856341287L,
				new Address("D089", "St. Louis Street", "Springfield", 62729));
		// payBill() is invoked
		double amount = customer.payBill(40.0);
		System.out.println("Final bill amount is $" + (int) (amount * 100)/ 100.0);
              //Regular Customer object created
                 RegularCustomer regularCustomer = new RegularCustomer("C101",
		  "Stephen Abram", 7856341287L, new Address("D089",
				"St. Louis Street", "Springfield", 62729));
            // payBill() is invoked
              amount = regularCustomer.payBill(40.0);
           System.out.println("Final bill amount is $" + (int) (amount * 100)/ 100.0);*/
            Customer regularCustomer = new RegularCustomer("C101", "Stephen Abram", 7856341287L, new Address("D089", "St. Louis            Street", "Springfield", 62729));
            double amount = regularCustomer.payBill(40.0);
           System.out.println(amount);
	}
}

// We are able to see that reference variable is of Parent type Customer and object is of the Child class RegularCustomer

    Customer customer=new RegularCustomer();
// The above line is an example of conversion/upcasting where we are converting the child class object into Parent class.
// So we are learning that the reference of Parent class can store the address if newly created child object.
   double=customer.payBill(40.0);
 // In the above line payBill of the Child class is called. So we have remember that here it is being due to the dynamic
// polymorphism which means that method is called whose reference we are storing in the reference variable
// In the above case though the reference variable is of Parent type but object of Child type.
// That is the reason when the methods are called we have the overriding and overridden methods, overriding method will be called(The method which is in the child class)   

    Customer customer=new Customer();
    RegularCustomer rc=new RegularCustomer():

---------------------------------------------------------------------------------------------------------------------
public class Parent10 {

    public void display(){
     System.out.println("Parent");
    
   }
  public void displayParent() {
    System.out.println("I am the display parent method");
 }
}

public class Child10 extends Parent10 {
    public void display(){
     System.out.println("Child");
    }
    public void displayChild(){
     System.out.println("I am the display child method");
 }
}
public class ParentChildMain10{
   public static void main(String args[]){
     Parent10 parent=new Parent10();
     parent.display();    // Parent
    Child10 child=new Child10();
    child.display();  // Child
    Parent10 parent1=new Child10();
    parent1.display(); // Child
    // It checks for display method in the Parent class , if it is found, it is checked in the Derived class because
   // object is of the Derived class. If it is found in the Derived class , that version of the method is called.
    parent1.displayChild(); // This line will show compilation error as this method is not present in the Parent class
// It checks whether the displayChild is present in the parent class or not as the reference variable is of Parent type
// as the method is not found in the Parent class , the code gives compilation error   

 parent1.displayParent(); // I am the display parent method
// In the above case first it is checked in the Parent class and when it is found in the parent class, it is checked
// in the subclass but in the subclass we dont have any method called displayParent so the displayParent of the Parent class is
// called
   }
}
-----------------------------------------------------------------------------------------------------------------------
public class Parent11 {

    public static void display(){
     System.out.println("Parent");
    
   }
 }

public class Child11 extends Parent11 {
    public static void display(){
     System.out.println("Child");
    }
  
 }

public class ParentChildMain11{
   public static void main(String args[]){
       Parent11 parent=new Child11();
        parent.display(); // Parent The reason is static methods are not related with object and that is the reason
      // There is no concept of method overriding as the static methods are related to the class. Here it will check the
      // Type of the reference variable. Because reference are created during the compilation time
   }
}

---------------------------------------------------------------


public class DynamicBindingTester {
	public static void main(String[] args) {
		Employee employee = new Employee();
		Manager manager = new Manager();
		Employee eduEmployee = new Educator();
		Educator managerEdu = new Manager();
		
		displayEmployeeDetails(employee);
		displayEmployeeDetails(manager);
		displayEmployeeDetails(eduEmployee);
		displayEmployeeDetails(managerEdu);
	}
	
	// Employee reference can accept its object and any of the child object 
	public static void displayEmployeeDetails(Employee employee) {
		employee.displayDetails();	// displayDetails invoked will be based on the object received
	}
}

public class Employee {
	String name = "James Anthony";
	
	public void displayDetails(){
		System.out.println(name+" is an employee");
	}	
}
public class Educator extends Employee {
	public void displayDetails(){
		System.out.println(name+" is an educator");
	}
}
public class Manager extends Educator {
	public void displayDetails(){
		System.out.println(name+" is a manager");
	}
}
------------------------------------------------------------------

public class DynamicBindingTester1 {
	public static void main(String[] args) {
		Employee1 employee = new Employee1();
		Manager1 manager = new Manager1();
		Employee1 eduEmployee = new Educator1();
		Educator1 managerEdu = new Manager1();
		
		displayEmployeeDetails(employee);   // This wont work
		displayEmployeeDetails(manager);     // This will work
		displayEmployeeDetails(eduEmployee);    // This wont work
		displayEmployeeDetails(managerEdu);     // This will work
	}
	
	// Employee reference can accept its object and any of the child object 
	public static void displayEmployeeDetails(Educator employee) {
		employee.displayDetails();	// displayDetails invoked will be based on the object received
	}
}

public class Employee1 {
	String name = "James Anthony";
	
	public void displayDetails(){
		System.out.println(name+" is an employee");
	}	
}
public class Educator1 extends Employee1 {
	public void displayDetails(){
		System.out.println(name+" is an educator");
	}
}
public class Manager1 extends Educator1 {
	public void displayDetails(){
		System.out.println(name+" is a manager");
	}
}
